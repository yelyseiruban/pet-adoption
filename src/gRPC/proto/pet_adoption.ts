// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: pet_adoption.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty } from "./google/protobuf/empty";

export const protobufPackage = "petadoption";

/** The Pet message */
export interface Pet {
  id: string;
  name: string;
  race: string;
  age: number;
  adopted: boolean;
}

/** The User message */
export interface User {
  id: string;
  name: string;
  canAdopt: boolean;
  pets: string[];
}

/** The Adoption message */
export interface Adoption {
  id: string;
  userId: string;
  petId: string;
  dateTime: string;
}

export interface CreatePetRequest {
  name: string;
  race: string;
  age: number;
}

export interface UpdatePetRequest {
  id: string;
  name: string;
  race: string;
  age: number;
}

export interface CreateUserRequest {
  name: string;
}

export interface CreateAdoptionRequest {
  userId: string;
  petId: string;
}

/** Response messages */
export interface CreatePetResponse {
  pet: Pet | undefined;
}

export interface CreateUserResponse {
  user: User | undefined;
}

export interface CreateAdoptionResponse {
  adoption: Adoption | undefined;
}

export interface PetsResponse {
  pet: Pet[];
}

export interface UsersResponse {
  user: User[];
}

export interface AdoptionsResponse {
  adoption: Adoption[];
}

/** Request messages */
export interface PetIdRequest {
  id: string;
}

export interface UserIdRequest {
  id: string;
}

function createBasePet(): Pet {
  return { id: "", name: "", race: "", age: 0, adopted: false };
}

export const Pet: MessageFns<Pet> = {
  encode(message: Pet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.race !== "") {
      writer.uint32(26).string(message.race);
    }
    if (message.age !== 0) {
      writer.uint32(32).int32(message.age);
    }
    if (message.adopted !== false) {
      writer.uint32(40).bool(message.adopted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.race = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.age = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.adopted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pet {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      race: isSet(object.race) ? globalThis.String(object.race) : "",
      age: isSet(object.age) ? globalThis.Number(object.age) : 0,
      adopted: isSet(object.adopted) ? globalThis.Boolean(object.adopted) : false,
    };
  },

  toJSON(message: Pet): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.race !== "") {
      obj.race = message.race;
    }
    if (message.age !== 0) {
      obj.age = Math.round(message.age);
    }
    if (message.adopted !== false) {
      obj.adopted = message.adopted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pet>, I>>(base?: I): Pet {
    return Pet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pet>, I>>(object: I): Pet {
    const message = createBasePet();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.race = object.race ?? "";
    message.age = object.age ?? 0;
    message.adopted = object.adopted ?? false;
    return message;
  },
};

function createBaseUser(): User {
  return { id: "", name: "", canAdopt: false, pets: [] };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.canAdopt !== false) {
      writer.uint32(24).bool(message.canAdopt);
    }
    for (const v of message.pets) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.canAdopt = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pets.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      canAdopt: isSet(object.canAdopt) ? globalThis.Boolean(object.canAdopt) : false,
      pets: globalThis.Array.isArray(object?.pets) ? object.pets.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.canAdopt !== false) {
      obj.canAdopt = message.canAdopt;
    }
    if (message.pets?.length) {
      obj.pets = message.pets;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.canAdopt = object.canAdopt ?? false;
    message.pets = object.pets?.map((e) => e) || [];
    return message;
  },
};

function createBaseAdoption(): Adoption {
  return { id: "", userId: "", petId: "", dateTime: "" };
}

export const Adoption: MessageFns<Adoption> = {
  encode(message: Adoption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.petId !== "") {
      writer.uint32(26).string(message.petId);
    }
    if (message.dateTime !== "") {
      writer.uint32(34).string(message.dateTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Adoption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdoption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.petId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dateTime = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Adoption {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      petId: isSet(object.petId) ? globalThis.String(object.petId) : "",
      dateTime: isSet(object.dateTime) ? globalThis.String(object.dateTime) : "",
    };
  },

  toJSON(message: Adoption): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.petId !== "") {
      obj.petId = message.petId;
    }
    if (message.dateTime !== "") {
      obj.dateTime = message.dateTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Adoption>, I>>(base?: I): Adoption {
    return Adoption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Adoption>, I>>(object: I): Adoption {
    const message = createBaseAdoption();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.petId = object.petId ?? "";
    message.dateTime = object.dateTime ?? "";
    return message;
  },
};

function createBaseCreatePetRequest(): CreatePetRequest {
  return { name: "", race: "", age: 0 };
}

export const CreatePetRequest: MessageFns<CreatePetRequest> = {
  encode(message: CreatePetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.race !== "") {
      writer.uint32(18).string(message.race);
    }
    if (message.age !== 0) {
      writer.uint32(24).int32(message.age);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.race = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.age = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      race: isSet(object.race) ? globalThis.String(object.race) : "",
      age: isSet(object.age) ? globalThis.Number(object.age) : 0,
    };
  },

  toJSON(message: CreatePetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.race !== "") {
      obj.race = message.race;
    }
    if (message.age !== 0) {
      obj.age = Math.round(message.age);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePetRequest>, I>>(base?: I): CreatePetRequest {
    return CreatePetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePetRequest>, I>>(object: I): CreatePetRequest {
    const message = createBaseCreatePetRequest();
    message.name = object.name ?? "";
    message.race = object.race ?? "";
    message.age = object.age ?? 0;
    return message;
  },
};

function createBaseUpdatePetRequest(): UpdatePetRequest {
  return { id: "", name: "", race: "", age: 0 };
}

export const UpdatePetRequest: MessageFns<UpdatePetRequest> = {
  encode(message: UpdatePetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.race !== "") {
      writer.uint32(26).string(message.race);
    }
    if (message.age !== 0) {
      writer.uint32(32).int32(message.age);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.race = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.age = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePetRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      race: isSet(object.race) ? globalThis.String(object.race) : "",
      age: isSet(object.age) ? globalThis.Number(object.age) : 0,
    };
  },

  toJSON(message: UpdatePetRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.race !== "") {
      obj.race = message.race;
    }
    if (message.age !== 0) {
      obj.age = Math.round(message.age);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePetRequest>, I>>(base?: I): UpdatePetRequest {
    return UpdatePetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePetRequest>, I>>(object: I): UpdatePetRequest {
    const message = createBaseUpdatePetRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.race = object.race ?? "";
    message.age = object.age ?? 0;
    return message;
  },
};

function createBaseCreateUserRequest(): CreateUserRequest {
  return { name: "" };
}

export const CreateUserRequest: MessageFns<CreateUserRequest> = {
  encode(message: CreateUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CreateUserRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUserRequest>, I>>(base?: I): CreateUserRequest {
    return CreateUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUserRequest>, I>>(object: I): CreateUserRequest {
    const message = createBaseCreateUserRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateAdoptionRequest(): CreateAdoptionRequest {
  return { userId: "", petId: "" };
}

export const CreateAdoptionRequest: MessageFns<CreateAdoptionRequest> = {
  encode(message: CreateAdoptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.petId !== "") {
      writer.uint32(18).string(message.petId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAdoptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAdoptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.petId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAdoptionRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      petId: isSet(object.petId) ? globalThis.String(object.petId) : "",
    };
  },

  toJSON(message: CreateAdoptionRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.petId !== "") {
      obj.petId = message.petId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateAdoptionRequest>, I>>(base?: I): CreateAdoptionRequest {
    return CreateAdoptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateAdoptionRequest>, I>>(object: I): CreateAdoptionRequest {
    const message = createBaseCreateAdoptionRequest();
    message.userId = object.userId ?? "";
    message.petId = object.petId ?? "";
    return message;
  },
};

function createBaseCreatePetResponse(): CreatePetResponse {
  return { pet: undefined };
}

export const CreatePetResponse: MessageFns<CreatePetResponse> = {
  encode(message: CreatePetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pet !== undefined) {
      Pet.encode(message.pet, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pet = Pet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePetResponse {
    return { pet: isSet(object.pet) ? Pet.fromJSON(object.pet) : undefined };
  },

  toJSON(message: CreatePetResponse): unknown {
    const obj: any = {};
    if (message.pet !== undefined) {
      obj.pet = Pet.toJSON(message.pet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePetResponse>, I>>(base?: I): CreatePetResponse {
    return CreatePetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePetResponse>, I>>(object: I): CreatePetResponse {
    const message = createBaseCreatePetResponse();
    message.pet = (object.pet !== undefined && object.pet !== null) ? Pet.fromPartial(object.pet) : undefined;
    return message;
  },
};

function createBaseCreateUserResponse(): CreateUserResponse {
  return { user: undefined };
}

export const CreateUserResponse: MessageFns<CreateUserResponse> = {
  encode(message: CreateUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: CreateUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUserResponse>, I>>(base?: I): CreateUserResponse {
    return CreateUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUserResponse>, I>>(object: I): CreateUserResponse {
    const message = createBaseCreateUserResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseCreateAdoptionResponse(): CreateAdoptionResponse {
  return { adoption: undefined };
}

export const CreateAdoptionResponse: MessageFns<CreateAdoptionResponse> = {
  encode(message: CreateAdoptionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.adoption !== undefined) {
      Adoption.encode(message.adoption, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAdoptionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAdoptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.adoption = Adoption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAdoptionResponse {
    return { adoption: isSet(object.adoption) ? Adoption.fromJSON(object.adoption) : undefined };
  },

  toJSON(message: CreateAdoptionResponse): unknown {
    const obj: any = {};
    if (message.adoption !== undefined) {
      obj.adoption = Adoption.toJSON(message.adoption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateAdoptionResponse>, I>>(base?: I): CreateAdoptionResponse {
    return CreateAdoptionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateAdoptionResponse>, I>>(object: I): CreateAdoptionResponse {
    const message = createBaseCreateAdoptionResponse();
    message.adoption = (object.adoption !== undefined && object.adoption !== null)
      ? Adoption.fromPartial(object.adoption)
      : undefined;
    return message;
  },
};

function createBasePetsResponse(): PetsResponse {
  return { pet: [] };
}

export const PetsResponse: MessageFns<PetsResponse> = {
  encode(message: PetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pet) {
      Pet.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pet.push(Pet.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PetsResponse {
    return { pet: globalThis.Array.isArray(object?.pet) ? object.pet.map((e: any) => Pet.fromJSON(e)) : [] };
  },

  toJSON(message: PetsResponse): unknown {
    const obj: any = {};
    if (message.pet?.length) {
      obj.pet = message.pet.map((e) => Pet.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PetsResponse>, I>>(base?: I): PetsResponse {
    return PetsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PetsResponse>, I>>(object: I): PetsResponse {
    const message = createBasePetsResponse();
    message.pet = object.pet?.map((e) => Pet.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUsersResponse(): UsersResponse {
  return { user: [] };
}

export const UsersResponse: MessageFns<UsersResponse> = {
  encode(message: UsersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.user) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UsersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user.push(User.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UsersResponse {
    return { user: globalThis.Array.isArray(object?.user) ? object.user.map((e: any) => User.fromJSON(e)) : [] };
  },

  toJSON(message: UsersResponse): unknown {
    const obj: any = {};
    if (message.user?.length) {
      obj.user = message.user.map((e) => User.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UsersResponse>, I>>(base?: I): UsersResponse {
    return UsersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UsersResponse>, I>>(object: I): UsersResponse {
    const message = createBaseUsersResponse();
    message.user = object.user?.map((e) => User.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAdoptionsResponse(): AdoptionsResponse {
  return { adoption: [] };
}

export const AdoptionsResponse: MessageFns<AdoptionsResponse> = {
  encode(message: AdoptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.adoption) {
      Adoption.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdoptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdoptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.adoption.push(Adoption.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdoptionsResponse {
    return {
      adoption: globalThis.Array.isArray(object?.adoption) ? object.adoption.map((e: any) => Adoption.fromJSON(e)) : [],
    };
  },

  toJSON(message: AdoptionsResponse): unknown {
    const obj: any = {};
    if (message.adoption?.length) {
      obj.adoption = message.adoption.map((e) => Adoption.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdoptionsResponse>, I>>(base?: I): AdoptionsResponse {
    return AdoptionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdoptionsResponse>, I>>(object: I): AdoptionsResponse {
    const message = createBaseAdoptionsResponse();
    message.adoption = object.adoption?.map((e) => Adoption.fromPartial(e)) || [];
    return message;
  },
};

function createBasePetIdRequest(): PetIdRequest {
  return { id: "" };
}

export const PetIdRequest: MessageFns<PetIdRequest> = {
  encode(message: PetIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PetIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePetIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PetIdRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: PetIdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PetIdRequest>, I>>(base?: I): PetIdRequest {
    return PetIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PetIdRequest>, I>>(object: I): PetIdRequest {
    const message = createBasePetIdRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseUserIdRequest(): UserIdRequest {
  return { id: "" };
}

export const UserIdRequest: MessageFns<UserIdRequest> = {
  encode(message: UserIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserIdRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: UserIdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserIdRequest>, I>>(base?: I): UserIdRequest {
    return UserIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserIdRequest>, I>>(object: I): UserIdRequest {
    const message = createBaseUserIdRequest();
    message.id = object.id ?? "";
    return message;
  },
};

/** Service definition */
export interface PetAdoptionService {
  GetPets(request: Empty): Promise<PetsResponse>;
  GetPet(request: PetIdRequest): Promise<Pet>;
  CreatePet(request: CreatePetRequest): Promise<CreatePetResponse>;
  UpdatePet(request: UpdatePetRequest): Promise<Pet>;
  DeletePet(request: PetIdRequest): Promise<Empty>;
  GetUsers(request: Empty): Promise<UsersResponse>;
  GetUser(request: UserIdRequest): Promise<User>;
  CreateUser(request: CreateUserRequest): Promise<CreateUserResponse>;
  UpdateUser(request: UserIdRequest): Promise<User>;
  DeleteUser(request: UserIdRequest): Promise<Empty>;
  VerifyUser(request: UserIdRequest): Promise<Empty>;
  GetAdoptions(request: Empty): Promise<AdoptionsResponse>;
  GetAdoption(request: PetIdRequest): Promise<Adoption>;
  DeleteAdoption(request: PetIdRequest): Promise<Empty>;
  CreateAdoption(request: CreateAdoptionRequest): Promise<CreateAdoptionResponse>;
}

export const PetAdoptionServiceServiceName = "petadoption.PetAdoptionService";
export class PetAdoptionServiceClientImpl implements PetAdoptionService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || PetAdoptionServiceServiceName;
    this.rpc = rpc;
    this.GetPets = this.GetPets.bind(this);
    this.GetPet = this.GetPet.bind(this);
    this.CreatePet = this.CreatePet.bind(this);
    this.UpdatePet = this.UpdatePet.bind(this);
    this.DeletePet = this.DeletePet.bind(this);
    this.GetUsers = this.GetUsers.bind(this);
    this.GetUser = this.GetUser.bind(this);
    this.CreateUser = this.CreateUser.bind(this);
    this.UpdateUser = this.UpdateUser.bind(this);
    this.DeleteUser = this.DeleteUser.bind(this);
    this.VerifyUser = this.VerifyUser.bind(this);
    this.GetAdoptions = this.GetAdoptions.bind(this);
    this.GetAdoption = this.GetAdoption.bind(this);
    this.DeleteAdoption = this.DeleteAdoption.bind(this);
    this.CreateAdoption = this.CreateAdoption.bind(this);
  }
  GetPets(request: Empty): Promise<PetsResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPets", data);
    return promise.then((data) => PetsResponse.decode(new BinaryReader(data)));
  }

  GetPet(request: PetIdRequest): Promise<Pet> {
    const data = PetIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPet", data);
    return promise.then((data) => Pet.decode(new BinaryReader(data)));
  }

  CreatePet(request: CreatePetRequest): Promise<CreatePetResponse> {
    const data = CreatePetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreatePet", data);
    return promise.then((data) => CreatePetResponse.decode(new BinaryReader(data)));
  }

  UpdatePet(request: UpdatePetRequest): Promise<Pet> {
    const data = UpdatePetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdatePet", data);
    return promise.then((data) => Pet.decode(new BinaryReader(data)));
  }

  DeletePet(request: PetIdRequest): Promise<Empty> {
    const data = PetIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeletePet", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  GetUsers(request: Empty): Promise<UsersResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUsers", data);
    return promise.then((data) => UsersResponse.decode(new BinaryReader(data)));
  }

  GetUser(request: UserIdRequest): Promise<User> {
    const data = UserIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUser", data);
    return promise.then((data) => User.decode(new BinaryReader(data)));
  }

  CreateUser(request: CreateUserRequest): Promise<CreateUserResponse> {
    const data = CreateUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateUser", data);
    return promise.then((data) => CreateUserResponse.decode(new BinaryReader(data)));
  }

  UpdateUser(request: UserIdRequest): Promise<User> {
    const data = UserIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateUser", data);
    return promise.then((data) => User.decode(new BinaryReader(data)));
  }

  DeleteUser(request: UserIdRequest): Promise<Empty> {
    const data = UserIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteUser", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  VerifyUser(request: UserIdRequest): Promise<Empty> {
    const data = UserIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VerifyUser", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  GetAdoptions(request: Empty): Promise<AdoptionsResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAdoptions", data);
    return promise.then((data) => AdoptionsResponse.decode(new BinaryReader(data)));
  }

  GetAdoption(request: PetIdRequest): Promise<Adoption> {
    const data = PetIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAdoption", data);
    return promise.then((data) => Adoption.decode(new BinaryReader(data)));
  }

  DeleteAdoption(request: PetIdRequest): Promise<Empty> {
    const data = PetIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteAdoption", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  CreateAdoption(request: CreateAdoptionRequest): Promise<CreateAdoptionResponse> {
    const data = CreateAdoptionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateAdoption", data);
    return promise.then((data) => CreateAdoptionResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
